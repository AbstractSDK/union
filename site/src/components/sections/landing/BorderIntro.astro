---
import MatrixCover from "../../MatrixCover.astro"
import H1 from "../../typography/h1.astro"
import TextP from "../../typography/TextP.astro"

interface Props {
  title: string
  text: string
}

const { title, text } = Astro.props

const slideTextAnimation = {
  forwards: {
    old: {
      name: "slideOutLeft",
      duration: "0.4s",
      easing: "ease-out",
      fillMode: "forwards"
    },
    new: {
      name: "slideInRight",
      duration: "0.4s",
      easing: "ease-out",
      fillMode: "forwards"
    }
  }
}
---

<div class="header-grid">
  <div class="glow-effect" transition:persist></div>
  <MatrixCover/>
  <div class="bg-gradient-to-r from-transparent via-black to-transparent px-4 py-6 text-center header-text-content flex justify-center">
    <div class="max-w-2xl flex flex-col gap-4" transition:animate={slideTextAnimation}>
      <H1>{title}</H1>
      <TextP>{text}</TextP>
    </div>
  </div>
</div>

<style lang="postcss" is:global>
    .header-grid {
        --outer-border: 3px;
        --inner-border: 1px;
        height: calc(100svh - 68px);
        width: 100%;
        display: grid;
        grid-template-rows: var(--outer-border) var(--inner-border) 1fr auto 1fr var(--inner-border) var(--outer-border);
        grid-template-columns: var(--outer-border) var(--inner-border) 1fr auto 1fr var(--inner-border) var(--outer-border);
        position: relative;
        overflow: hidden;
    }

    .glow-effect {
        grid-area: 3 / 3 / 6 / 6;
        background: conic-gradient(
                from 0deg at 50% 50%,
                rgba(160, 236, 253, 1) 15deg,
                rgba(160, 236, 253, 0) 15deg,
                rgba(160, 236, 253, 0) 55deg,
                rgba(160, 236, 253, 0) 345deg,
                rgba(160, 236, 253, 1) 345deg
        );
        z-index: 2;
        mix-blend-mode: screen;
        transition: transform 0.1s ease-out;
        transform: scale(10);
    }

    .header-grid > canvas {
        grid-area: 3 / 3 / 6 / 6;
        background-color: transparent;
        z-index: 3;
    }

    .header-text-content {
        grid-area: 4 / 3 / 5 / 6;
        z-index: 4;
    }
</style>

<script>
  import {rotateCamera} from "../../../lib/matrix-cover";

  document.addEventListener('astro:after-preparation', (e) => {
    rotateCamera();
  });

  let headerGrid;
  let glowEffect;
  let previousAngle = 0;
  let currentRotation = 0;
  let mouseMoveHandler;

  function initializeGlowEffect() {
    headerGrid = document.querySelector('.header-grid');
    glowEffect = document.querySelector('.glow-effect');

    if (headerGrid && glowEffect) {
      mouseMoveHandler = (e) => {
        const rect = headerGrid.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const deltaX = e.clientX - centerX;
        const deltaY = e.clientY - centerY;
        const newAngle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const scale = Math.max(4, (distance / rect.height) * 8);

        let angleDiff = newAngle - previousAngle;

        if (angleDiff > 180) {
          angleDiff -= 360;
        } else if (angleDiff < -180) {
          angleDiff += 360;
        }

        currentRotation += angleDiff;
        previousAngle = newAngle;

        glowEffect.style.transform = `scale(${scale}) rotate(${currentRotation + 90}deg)`;
      };

      headerGrid.addEventListener('mousemove', mouseMoveHandler);
    }
  }

  function cleanup() {
    if (headerGrid && mouseMoveHandler) {
      headerGrid.removeEventListener('mousemove', mouseMoveHandler);
    }
  }

  document.addEventListener('astro:page-load', () => {
    cleanup();
    initializeGlowEffect();
  });

  document.addEventListener('astro:before-preparation', cleanup);
</script>